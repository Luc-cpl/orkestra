"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[800],{8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var s=i(6540);const r={},c=s.createContext(r);function t(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(c.Provider,{value:n},e.children)}},9826:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>t,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/dependency-injection","title":"Dependency Injection","description":"Orkestra includes a powerful Dependency Injection (DI) container built on PHP-DI, providing a clean and efficient way to manage class dependencies. This guide covers the core DI patterns used in Orkestra applications.","source":"@site/docs/core-concepts/dependency-injection.md","sourceDirName":"core-concepts","slug":"/core-concepts/dependency-injection","permalink":"/orkestra/docs/core-concepts/dependency-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/Luc-cpl/orkestra/tree/main/docs/docs/core-concepts/dependency-injection.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Application Lifecycle","permalink":"/orkestra/docs/core-concepts/app-lifecycle"},"next":{"title":"Configuration Management","permalink":"/orkestra/docs/core-concepts/configuration-management"}}');var r=i(4848),c=i(8453);const t={sidebar_position:2},a="Dependency Injection",o={},l=[{value:"Basic Container Usage",id:"basic-container-usage",level:2},{value:"Accessing the Application Instance",id:"accessing-the-application-instance",level:3},{value:"Accessing the Application Instance in Tests",id:"accessing-the-application-instance-in-tests",level:3},{value:"Binding Services",id:"binding-services",level:3},{value:"Retrieving Services",id:"retrieving-services",level:3},{value:"Checking Service Availability",id:"checking-service-availability",level:3},{value:"Advanced Container Features",id:"advanced-container-features",level:2},{value:"Service Decoration",id:"service-decoration",level:3},{value:"AppBind for Complex Bindings",id:"appbind-for-complex-bindings",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Example 1: Repository Pattern with DI",id:"example-1-repository-pattern-with-di",level:3},{value:"Example 2: Service Decoration for Caching",id:"example-2-service-decoration-for-caching",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"Circular Dependencies",id:"circular-dependencies",level:3},{value:"Container in Domain Objects",id:"container-in-domain-objects",level:3},{value:"Related Topics",id:"related-topics",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,r.jsx)(n.p,{children:"Orkestra includes a powerful Dependency Injection (DI) container built on PHP-DI, providing a clean and efficient way to manage class dependencies. This guide covers the core DI patterns used in Orkestra applications."}),"\n",(0,r.jsx)(n.h2,{id:"basic-container-usage",children:"Basic Container Usage"}),"\n",(0,r.jsx)(n.p,{children:"The container is the central registry for all your application's services and dependencies. Here's how to use it:"}),"\n",(0,r.jsx)(n.h3,{id:"accessing-the-application-instance",children:"Accessing the Application Instance"}),"\n",(0,r.jsx)(n.p,{children:"In Orkestra applications, you need to work with the application instance directly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// In your application where you have access to the $app instance\n$app = new Orkestra\\App($config);\n\n// If you're using the Orkestra skeleton, App\\app() helper is available\n$app = App\\app();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"accessing-the-application-instance-in-tests",children:"Accessing the Application Instance in Tests"}),"\n",(0,r.jsxs)(n.p,{children:["In your tests you can extend the test UseCase class with the ",(0,r.jsx)(n.code,{children:"Orkestra\\Testing\\Traits\\HasApplicationTrait"})," trait:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Orkestra\\Testing\\Traits\\HasApplicationTrait;\n\nclass MyTestCase extends TestCase\n{\n    use HasApplicationTrait;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This will add some helper functions to help you access the application instance and other services during testing (very useful for feature tests):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"app()"})," - Get the application instance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"factory()"})," - Get the entity factory instance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"request()"})," - Simulates a API request"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"middleware()"})," - Create a middleware testing instance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"generateRequest()"})," - Generate a request instance"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"binding-services",children:"Binding Services"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// Bind a closure\n$app->bind('service_name', fn() => 'service_value');\n\n// Bind a class by name (with autowiring)\n$app->bind('service_name', MyClass::class);\n\n// Bind a class instance directly\n$instance = new MyClass();\n$app->bind('service_name', $instance);\n\n// Bind an interface to an implementation\n$app->bind(MyInterface::class, MyImplementation::class);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"retrieving-services",children:"Retrieving Services"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// Get a service from the container\n$service = $app->get('service_name');\n\n// Make a new instance with parameters\n$service = $app->make('service_name', ['param' => 'value']);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"checking-service-availability",children:"Checking Service Availability"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// Check if a service exists in the container\nif ($app->has('service_name')) {\n    // Service exists\n}\n\n// Run a callback only if a service is available\n$result = $app->runIfAvailable(MyClass::class, function ($instance) {\n    return $instance->doSomething();\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-container-features",children:"Advanced Container Features"}),"\n",(0,r.jsx)(n.h3,{id:"service-decoration",children:"Service Decoration"}),"\n",(0,r.jsx)(n.p,{children:"Decoration allows you to modify or extend a service without changing its original implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// Decorate an existing service\n$app->bind(MyService::class, fn() => new MyService());\n$app->decorate(MyService::class, function($service) {\n    return new MyServiceDecorator($service);\n});\n\n// Decorate before binding (order doesn't matter)\n$app->decorate(MyInterface::class, function($service) {\n    return new MyDecorator($service);\n});\n$app->bind(MyInterface::class, MyImplementation::class);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"appbind-for-complex-bindings",children:"AppBind for Complex Bindings"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"AppBind"})," class provides more control over service definition:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// Create a bind with constructor parameters\n$bind = new AppBind('service_name', MyClass::class);\n$bind->constructor('param1', 'param2');\n\n// Set properties on the service\n$bind = new AppBind('service_name', MyClass::class);\n$bind->property('propertyName', 'propertyValue');\n\n// Inject method parameters\n$bind = new AppBind('service_name', MyClass::class);\n$bind->method('methodName', 'param1', 'param2');\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Favor Interface Bindings"}),": Bind interfaces to implementations for better testability and loose coupling."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"interface UserRepositoryInterface { /* ... */ }\nclass UserRepository implements UserRepositoryInterface { /* ... */ }\n\n$app->bind(UserRepositoryInterface::class, UserRepository::class);\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Autowiring"}),": Let the container resolve dependencies automatically when possible."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Contextual Binding"}),": Configure different implementations for the same interface in different contexts."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Avoid Container in Business Logic"}),": Keep the container usage at the composition root level."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Decoration for Cross-Cutting Concerns"}),": Logging, caching, and authorization are great use cases for decoration."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-1-repository-pattern-with-di",children:"Example 1: Repository Pattern with DI"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"interface UserRepositoryInterface {\n    public function findById(int $id): ?User;\n}\n\nclass UserRepository implements UserRepositoryInterface {\n    public function findById(int $id): ?User {\n        // Implementation...\n    }\n}\n\nclass UserService {\n    private UserRepositoryInterface $repository;\n    \n    public function __construct(UserRepositoryInterface $repository) {\n        $this->repository = $repository;\n    }\n    \n    public function getUser(int $id): ?User {\n        return $this->repository->findById($id);\n    }\n}\n\n// In a service provider:\npublic function register(App $app): void {\n    $app->bind(UserRepositoryInterface::class, UserRepository::class);\n    $app->bind(UserService::class, UserService::class);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-2-service-decoration-for-caching",children:"Example 2: Service Decoration for Caching"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"$app->bind(UserRepositoryInterface::class, UserRepository::class);\n\n$app->decorate(UserRepositoryInterface::class, function ($repository) {\n    return new CachedUserRepository($repository);\n});\n\nclass CachedUserRepository implements UserRepositoryInterface {\n    private UserRepositoryInterface $repository;\n    private CacheInterface $cache;\n    \n    public function __construct(UserRepositoryInterface $repository, CacheInterface $cache = null) {\n        $this->repository = $repository;\n        // Note: In a real application, you should inject dependencies properly\n        // rather than accessing the container directly\n        $this->cache = $cache ?? $this->getCache();\n    }\n    \n    private function getCache(): CacheInterface {\n        // Get from DI container. In skeleton project, you might use App\\app()\n        // In regular Orkestra apps, you should inject this dependency instead\n        return $GLOBALS['app']->get(CacheInterface::class);\n    }\n    \n    public function findById(int $id): ?User {\n        $cacheKey = \"user.{$id}\";\n        \n        if ($this->cache->has($cacheKey)) {\n            return $this->cache->get($cacheKey);\n        }\n        \n        $user = $this->repository->findById($id);\n        $this->cache->set($cacheKey, $user);\n        \n        return $user;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,r.jsx)(n.h3,{id:"circular-dependencies",children:"Circular Dependencies"}),"\n",(0,r.jsx)(n.p,{children:"Be careful with circular dependencies. When class A depends on class B, and class B depends on class A, you'll encounter issues:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Refactor to break the circular dependency, or use a factory pattern."]}),"\n",(0,r.jsx)(n.h3,{id:"container-in-domain-objects",children:"Container in Domain Objects"}),"\n",(0,r.jsx)(n.p,{children:"Avoid directly accessing the application container in domain objects:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// BAD\nclass UserService {\n    public function getUser(int $id): ?User {\n        // Don't access container directly in your domain logic\n        $repository = App\\app()->get(UserRepositoryInterface::class);\n        return $repository->findById($id);\n    }\n}\n\n// GOOD\nclass UserService {\n    private UserRepositoryInterface $repository;\n    \n    public function __construct(UserRepositoryInterface $repository) {\n        $this->repository = $repository;\n    }\n    \n    public function getUser(int $id): ?User {\n        return $this->repository->findById($id);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/guides/providers",children:"Service Providers"})," - Register and manage services"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/core-concepts/app-lifecycle",children:"Application Lifecycle"})," - Understand application bootstrapping"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);