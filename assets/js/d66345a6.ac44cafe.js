"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[176],{1266:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"guides/service-decoration","title":"Service Decoration","description":"Orkestra provides a powerful service decoration system that allows you to modify or extend the behavior of services without changing their original implementation. This guide explains how to use service decoration effectively.","source":"@site/docs/guides/service-decoration.md","sourceDirName":"guides","slug":"/guides/service-decoration","permalink":"/orkestra/docs/guides/service-decoration","draft":false,"unlisted":false,"editUrl":"https://github.com/Luc-cpl/orkestra/tree/main/docs/docs/guides/service-decoration.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Entities","permalink":"/orkestra/docs/guides/entities"},"next":{"title":"Testing Orkestra Applications","permalink":"/orkestra/docs/advanced-topics/testing"}}');var t=i(4848),a=i(8453);const c={sidebar_position:5},o="Service Decoration",s={},l=[{value:"Understanding Service Decoration",id:"understanding-service-decoration",level:2},{value:"Basic Decoration",id:"basic-decoration",level:2},{value:"Decoration Order",id:"decoration-order",level:3},{value:"Interface-Based Decoration",id:"interface-based-decoration",level:2},{value:"Decorator Implementation",id:"decorator-implementation",level:2},{value:"Advanced Decoration Patterns",id:"advanced-decoration-patterns",level:2},{value:"Conditional Decoration",id:"conditional-decoration",level:3},{value:"Decoration Before Binding",id:"decoration-before-binding",level:3},{value:"Multiple Interface Decoration",id:"multiple-interface-decoration",level:3},{value:"Real-World Decoration Examples",id:"real-world-decoration-examples",level:2},{value:"Caching Decorator",id:"caching-decorator",level:3},{value:"Transaction Decorator",id:"transaction-decorator",level:3},{value:"Rate Limiting Decorator",id:"rate-limiting-decorator",level:3},{value:"Testing Decorated Services",id:"testing-decorated-services",level:2},{value:"Testing Individual Decorators",id:"testing-individual-decorators",level:3},{value:"Testing the Decoration Chain",id:"testing-the-decoration-chain",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"service-decoration",children:"Service Decoration"})}),"\n",(0,t.jsx)(n.p,{children:"Orkestra provides a powerful service decoration system that allows you to modify or extend the behavior of services without changing their original implementation. This guide explains how to use service decoration effectively."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-service-decoration",children:"Understanding Service Decoration"}),"\n",(0,t.jsxs)(n.p,{children:["Service decoration follows the ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Decorator_pattern",children:"Decorator pattern"}),", allowing you to wrap a service with additional functionality. This is particularly useful for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Adding cross-cutting concerns like logging, caching, or validation"}),"\n",(0,t.jsx)(n.li,{children:"Conditionally enhancing services based on environment or configuration"}),"\n",(0,t.jsx)(n.li,{children:"Creating feature toggles and A/B testing"}),"\n",(0,t.jsxs)(n.li,{children:["Implementing ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern",children:"Chain of Responsibility"})," patterns"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-decoration",children:"Basic Decoration"}),"\n",(0,t.jsxs)(n.p,{children:["The most common way to decorate a service is using the ",(0,t.jsx)(n.code,{children:"decorate()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// First, bind the original service\n$app->bind(MyService::class, fn() => new MyService());\n\n// Then, decorate it with additional functionality\n$app->decorate(MyService::class, function($service) {\n    return new MyServiceDecorator($service);\n});\n\n// When you retrieve the service, you get the decorated version\n$service = $app->get(MyService::class); // Returns MyServiceDecorator instance\n"})}),"\n",(0,t.jsx)(n.h3,{id:"decoration-order",children:"Decoration Order"}),"\n",(0,t.jsx)(n.p,{children:"Multiple decorators can be applied to the same service. They are applied in the order they are registered:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$app->bind(MyService::class, fn() => new MyService());\n\n// First decorator\n$app->decorate(MyService::class, function($service) {\n    return new LoggingDecorator($service);\n});\n\n// Second decorator (wraps the LoggingDecorator)\n$app->decorate(MyService::class, function($service) {\n    return new CachingDecorator($service);\n});\n\n// The resulting chain is: CachingDecorator -> LoggingDecorator -> MyService\n$service = $app->get(MyService::class);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"interface-based-decoration",children:"Interface-Based Decoration"}),"\n",(0,t.jsx)(n.p,{children:"A particularly powerful use of decoration is with interfaces. You can bind an interface to an implementation and then decorate that interface:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"interface UserRepositoryInterface\n{\n    public function findById(int $id): ?User;\n}\n\nclass UserRepository implements UserRepositoryInterface\n{\n    public function findById(int $id): ?User\n    {\n        // Implementation...\n    }\n}\n\n// Bind the interface to the implementation\n$app->bind(UserRepositoryInterface::class, UserRepository::class);\n\n// Decorate the interface\n$app->decorate(UserRepositoryInterface::class, function($repository) {\n    return new CachedUserRepository($repository);\n});\n\n// When you retrieve the interface, you get the decorated implementation\n$repository = $app->get(UserRepositoryInterface::class); // Returns CachedUserRepository\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows you to keep your application code dependent on interfaces rather than concrete implementations while still using decoration."}),"\n",(0,t.jsx)(n.h2,{id:"decorator-implementation",children:"Decorator Implementation"}),"\n",(0,t.jsx)(n.p,{children:"A decorator typically:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Implements the same interface as the decorated service"}),"\n",(0,t.jsx)(n.li,{children:"Holds a reference to the decorated service"}),"\n",(0,t.jsx)(n.li,{children:"Delegates to the decorated service while adding its own behavior"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"interface LoggerInterface\n{\n    public function log(string $message): void;\n}\n\nclass FileLogger implements LoggerInterface\n{\n    public function log(string $message): void\n    {\n        file_put_contents('app.log', $message . PHP_EOL, FILE_APPEND);\n    }\n}\n\nclass FormattingLogger implements LoggerInterface\n{\n    private LoggerInterface $logger;\n    \n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n    \n    public function log(string $message): void\n    {\n        $timestamp = date('Y-m-d H:i:s');\n        $formattedMessage = \"[{$timestamp}] {$message}\";\n        $this->logger->log($formattedMessage);\n    }\n}\n\n// Usage in a service provider\npublic function register(App $app): void\n{\n    $app->bind(LoggerInterface::class, FileLogger::class);\n    $app->decorate(LoggerInterface::class, function($logger) {\n        return new FormattingLogger($logger);\n    });\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-decoration-patterns",children:"Advanced Decoration Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"conditional-decoration",children:"Conditional Decoration"}),"\n",(0,t.jsx)(n.p,{children:"You can apply decorators conditionally based on configuration or environment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"public function register(App $app): void\n{\n    // Bind the base implementation\n    $app->bind(CacheInterface::class, FileCache::class);\n    \n    // Apply Redis cache decorator only if Redis is available\n    if (extension_loaded('redis')) {\n        $app->decorate(CacheInterface::class, function($cache) {\n            return new RedisCache($cache); // Falls back to FileCache if Redis fails\n        });\n    }\n    \n    // Apply debugging decorator only in development\n    if ($app->config()->get('env') === 'development') {\n        $app->decorate(CacheInterface::class, function($cache) {\n            return new DebuggingCache($cache);\n        });\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"decoration-before-binding",children:"Decoration Before Binding"}),"\n",(0,t.jsx)(n.p,{children:"You can register decorators before the service is even bound. The decorators will be applied when the service is eventually bound:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"public function register(App $app): void\n{\n    // Register a decorator first\n    $app->decorate(PaymentGatewayInterface::class, function($gateway) {\n        return new LoggingPaymentGateway($gateway);\n    });\n    \n    // Later, bind the interface\n    $app->bind(PaymentGatewayInterface::class, StripeGateway::class);\n    \n    // The service is automatically decorated when retrieved\n    // $app->get(PaymentGatewayInterface::class) will return LoggingPaymentGateway\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-interface-decoration",children:"Multiple Interface Decoration"}),"\n",(0,t.jsx)(n.p,{children:"A service can implement multiple interfaces, and each interface can be decorated independently:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"interface Readable\n{\n    public function read(string $key): mixed;\n}\n\ninterface Writable\n{\n    public function write(string $key, mixed $value): void;\n}\n\nclass Storage implements Readable, Writable\n{\n    // Implementation...\n}\n\npublic function register(App $app): void\n{\n    // Decorate the Readable interface\n    $app->bind(Readable::class, Storage::class);\n    $app->decorate(Readable::class, function($storage) {\n        return new CachedReadable($storage);\n    });\n    \n    // Decorate the Writable interface\n    $app->bind(Writable::class, Storage::class);\n    $app->decorate(Writable::class, function($storage) {\n        return new ValidatedWritable($storage);\n    });\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"real-world-decoration-examples",children:"Real-World Decoration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"caching-decorator",children:"Caching Decorator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:'class CachedUserRepository implements UserRepositoryInterface\n{\n    private UserRepositoryInterface $repository;\n    private CacheInterface $cache;\n    \n    public function __construct(\n        UserRepositoryInterface $repository,\n        CacheInterface $cache\n    ) {\n        $this->repository = $repository;\n        $this->cache = $cache;\n    }\n    \n    public function findById(int $id): ?User\n    {\n        $cacheKey = "user.{$id}";\n        \n        if ($this->cache->has($cacheKey)) {\n            return $this->cache->get($cacheKey);\n        }\n        \n        $user = $this->repository->findById($id);\n        \n        if ($user) {\n            $this->cache->set($cacheKey, $user, 3600); // Cache for 1 hour\n        }\n        \n        return $user;\n    }\n}\n\n// In a service provider\npublic function register(App $app): void\n{\n    // Register the repository\n    $app->bind(UserRepositoryInterface::class, UserRepository::class);\n    \n    // Decorate with caching\n    $app->decorate(UserRepositoryInterface::class, function($repository) use ($app) {\n        return new CachedUserRepository(\n            $repository,\n            $app->get(CacheInterface::class)\n        );\n    });\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"transaction-decorator",children:"Transaction Decorator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class TransactionalUserService implements UserServiceInterface\n{\n    private UserServiceInterface $service;\n    private DatabaseInterface $database;\n    \n    public function __construct(\n        UserServiceInterface $service,\n        DatabaseInterface $database\n    ) {\n        $this->service = $service;\n        $this->database = $database;\n    }\n    \n    public function updateUser(User $user): bool\n    {\n        $this->database->beginTransaction();\n        \n        try {\n            $result = $this->service->updateUser($user);\n            $this->database->commit();\n            return $result;\n        } catch (Exception $e) {\n            $this->database->rollback();\n            throw $e;\n        }\n    }\n}\n\n// In a service provider\npublic function register(App $app): void\n{\n    $app->bind(UserServiceInterface::class, UserService::class);\n    \n    $app->decorate(UserServiceInterface::class, function($service) use ($app) {\n        return new TransactionalUserService(\n            $service,\n            $app->get(DatabaseInterface::class)\n        );\n    });\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"rate-limiting-decorator",children:"Rate Limiting Decorator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class RateLimitedApiClient implements ApiClientInterface\n{\n    private ApiClientInterface $client;\n    private RateLimiterInterface $rateLimiter;\n    \n    public function __construct(\n        ApiClientInterface $client,\n        RateLimiterInterface $rateLimiter\n    ) {\n        $this->client = $client;\n        $this->rateLimiter = $rateLimiter;\n    }\n    \n    public function request(string $endpoint, array $data = []): array\n    {\n        if (!$this->rateLimiter->allowRequest()) {\n            throw new RateLimitExceededException('API rate limit exceeded');\n        }\n        \n        return $this->client->request($endpoint, $data);\n    }\n}\n\n// In a service provider\npublic function register(App $app): void\n{\n    $app->bind(ApiClientInterface::class, HttpApiClient::class);\n    \n    $app->decorate(ApiClientInterface::class, function($client) use ($app) {\n        return new RateLimitedApiClient(\n            $client,\n            $app->get(RateLimiterInterface::class)\n        );\n    });\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-decorated-services",children:"Testing Decorated Services"}),"\n",(0,t.jsx)(n.p,{children:"When testing decorated services, you can test both the individual decorators and the entire decoration chain:"}),"\n",(0,t.jsx)(n.h3,{id:"testing-individual-decorators",children:"Testing Individual Decorators"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"test('caching decorator returns cached user', function () {\n    // Create a mock repository\n    $repository = Mockery::mock(UserRepositoryInterface::class);\n    $repository->shouldReceive('findById')\n        ->with(1)\n        ->once() // Should be called only once\n        ->andReturn(new User(['id' => 1, 'name' => 'Test User']));\n    \n    // Create a real cache\n    $cache = new ArrayCache();\n    \n    // Create the decorator\n    $cachedRepository = new CachedUserRepository($repository, $cache);\n    \n    // First call should hit the repository\n    $user1 = $cachedRepository->findById(1);\n    expect($user1->name)->toBe('Test User');\n    \n    // Second call should hit the cache, not the repository\n    $user2 = $cachedRepository->findById(1);\n    expect($user2->name)->toBe('Test User');\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"testing-the-decoration-chain",children:"Testing the Decoration Chain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"test('can retrieve fully decorated service', function () {\n    // Create application\n    $app = new Orkestra\\App(new Orkestra\\Configuration());\n    \n    // Bind the base service\n    $app->bind(LoggerInterface::class, fn() => new FileLogger());\n    \n    // Add decorators\n    $app->decorate(LoggerInterface::class, function($logger) {\n        return new TimestampLogger($logger);\n    });\n    \n    $app->decorate(LoggerInterface::class, function($logger) {\n        return new JsonLogger($logger);\n    });\n    \n    // Boot the application\n    $app->boot();\n    \n    // Get the fully decorated service\n    $logger = $app->get(LoggerInterface::class);\n    \n    // Test that it's the outermost decorator\n    expect($logger)->toBeInstanceOf(JsonLogger::class);\n    \n    // Test that the decoration chain works\n    $logFile = 'app.log';\n    @unlink($logFile); // Clear log file\n    \n    $logger->log(['message' => 'Test message']);\n    \n    $logContent = file_get_contents($logFile);\n    expect($logContent)->toContain('\"message\":\"Test message\"');\n    expect($logContent)->toContain('\"timestamp\":\"');\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Decorate Interfaces, Not Implementations"}),": Whenever possible, apply decorators to interfaces rather than concrete classes for better flexibility and testability."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Follow the Single Responsibility Principle"}),": Each decorator should add only one piece of functionality. For complex behavior, use multiple decorators."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Keep the Same Interface"}),": Decorators should implement the same interface as the decorated service to ensure compatibility."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Forward Unknown Methods"}),": If decorating a service with many methods, consider implementing ",(0,t.jsx)(n.code,{children:"__call()"})," to forward any unhandled methods to the decorated service."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Constructor Injection"}),": Pass the decorated service via constructor, not through the container, to make testing easier."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Apply Decorators in the Right Order"}),": Consider the order of decorators carefully. For example, caching typically should come after validation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Make Decorators Configurable"}),": Allow decorators to be configured (e.g., cache duration, log level) for greater flexibility."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use the $app Instance in Closures"}),": When accessing the application instance in decorator closures, always use the ",(0,t.jsx)(n.code,{children:"use ($app)"})," syntax to capture the variable instead of relying on global functions."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts/dependency-injection",children:"Dependency Injection"})," - Understanding the service container"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/providers",children:"Service Providers"})," - Managing service registration and decoration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/advanced-topics/testing",children:"Testing"})," - Testing Orkestra applications"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>o});var r=i(6540);const t={},a=r.createContext(t);function c(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);